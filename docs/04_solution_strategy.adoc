ifndef::imagesdir[:imagesdir: images]

[[section-solution-strategy]]
== Lösungsstrategie

Dieses Kapitel beschreibt die grundlegende Lösungsstrategie der Softwarearchitektur für den Steckinator 3000.
Die Software ist modular aufgebaut und folgt einer klar strukturierten Verarbeitungskette, welche vom Erfassen der
Puzzleteile bis zur Berechnung der Roboterbewegungen reicht. Jeder Teilbereich ist funktional abgegrenzt und kann
unabhängig getestet, angepasst oder erweitert werden. Zentrales Element zur Validierung der Lösungsstrategie ist ein
Simulator, der die komplette Puzzle-Logik abbildet.

=== Objekterkennung

Die Objekterkennung ist der erste Verarbeitungsschritt der Software und dient dazu,
die einzelnen Puzzleteile zuverlässig im Kamerabild zu identifizieren. Die Lösung basiert auf
klassischer Bildverarbeitung mit OpenCV. Nach der Umwandlung des Kamerabildes in ein Graustufenbild
werden Störungen durch Weichzeichnung reduziert und anschliessend mittels Binarisierung Vorder- und Hintergrund
getrennt. Über eine Konturerkennung werden die Umrisse der Puzzleteile extrahiert. Kleine Störungen oder
Artefakte werden über Flächenfilter verworfen. Das Ergebnis dieses Schrittes sind saubere Aussenkonturen
aller erkannten Puzzleteile.

=== Kantenseparation

Ziel der Kantenseparation ist es, die Konturen der Puzzleteile in einzelne, vergleichbare Kanten zu unterteilen.
Dazu werden aus der Kontur stabile Eckpunkte bestimmt, welche als Trennstellen für die Kanten dienen.
Die Kontur wird anschliessend in Segmente zerlegt und den jeweiligen Seiten des Puzzleteils zugeordnet.
Dieser Schritt reduziert die Komplexität der Konturdaten und schafft die Grundlage für einen gezielten
und strukturierten Kantenvergleich.

=== Kantenvergleich (Matching)

Der Kantenvergleich dient dazu, passende Kantenpaare zwischen unterschiedlichen Puzzleteilen zu identifizieren.
Hierfür werden alle relevanten Kanten geometrisch normalisiert, sodass sie unabhängig von Position, Rotation und
Skalierung vergleichbar sind. Zusätzlich werden die Kanten grob typisiert (z. B. Puzzlenase, Einbuchtung oder
flache Kante), um unplausible Vergleiche frühzeitig auszuschliessen. Der eigentliche Vergleich erfolgt über einen
Brute-Force-Ansatz, welcher aufgrund der geringen Anzahl von Puzzleteilen performant genug ist. Das Ergebnis ist
eine Liste von Kantenpaaren mit zugehörigen Übereinstimmungswerten.

=== Puzzle-Zusammensetzung

Basierend auf den ermittelten Kantenmatches werden die Puzzleteile virtuell zusammengesetzt.
Ein geeignetes Eckteil dient dabei als Start- oder Ankerpunkt. Weitere Teile werden iterativ anhand der
Matching-Beziehungen positioniert und ausgerichtet. Dieser Schritt erzeugt eine konsistente Zielanordnung
aller Puzzleteile im gelösten Zustand, unabhängig von deren ursprünglicher Lage.

=== Koordinatensystem und Skalierung

Um virtuelle Berechnungen mit der realen Arbeitsfläche des Roboters zu verknüpfen, wird ein einheitliches
Koordinatensystem eingeführt. Die aus der Bildverarbeitung gewonnenen Konturen werden skaliert und verschoben,
sodass sie den realen Abmessungen des Spielfelds entsprechen. Dadurch können sowohl die Ausgangspositionen der
Puzzleteile als auch deren Zielpositionen im selben Referenzsystem beschrieben werden.

=== Berechnung von Rotation und Translation (S-Output Generierung)

Dieses Modul führt die kritische Risikominimierung durch, indem es die **exakten Bewegungsbefehle** für das spätere physische System generiert und protokolliert.

==== Koordinatensystem und Skalierung

Der Simulator arbeitet mit einem virtuellen Koordinatensystem, das an die realen Abmessungen der A4-Startzone und des A5-Zielrahmens gebunden ist.

* Die geladenen Konturdaten werden auf die korrekten **Skalierungsfaktoren** normiert.
* Das System enthält nach diesem Schritt zwei Datensätze: die **Ausgangsposition** (ungelöst) und die **Endposition** (gelöst) im gleichen virtuellen Raum.

==== Berechnung der Rotation

Die Rotation ist die Differenz im Winkel zwischen der aktuellen Orientierung des Puzzleteils und der benötigten Endorientierung im gelösten Zustand.

* **Methode:** Bestimmung eines Referenzvektors für jedes Teil im ungelösten und gelösten Zustand.
* **Resultat:** Berechnung des Rotationswinkels um den Flächenschwerpunkt.

==== Berechnung der Translation

Die Translation ist die Distanz, die das Puzzleteil (nach der Rotation) verschoben werden muss, um seine finale Position zu erreichen.

* **Methode:** Berechnung der Differenz der X- und Y-Koordinaten (Verschiebung) zwischen einem Referenzpunkt des ungelösten und des gelösten Puzzleteils.
* **S-Output:** Die **Rotation und Translation** für jedes Teil werden als *S-Output* generiert und in den S-Log protokolliert (z.B. "Place Teil X: Rotate 45°, Translate (424, 40)").



